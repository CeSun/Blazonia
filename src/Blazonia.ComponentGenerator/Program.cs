// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

using Blazonia.ComponentGenerator.Extensions;
using CommandLine;
using Microsoft.Build.Locator;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace Blazonia.ComponentGenerator;

public class Program
{
    const string FileHeader = @"// <auto-generated>
//     This code was generated by a BlazorBindingsAvalonia component generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
";

    public static async Task Main(string[] args)
    {
        MSBuildLocator.RegisterInstance(MSBuildLocator.QueryVisualStudioInstances().MaxBy(instance => instance.Version));

        await Parser.Default
            .ParseArguments<Options>(args)
            .WithParsedAsync(async o =>
            {
                if (o.ProjectPath is null)
                {
                    o.ProjectPath = Directory.GetFiles(Directory.GetCurrentDirectory()).FirstOrDefault(f
                        => f.EndsWith(".csproj", StringComparison.OrdinalIgnoreCase))
                        ?? throw new Exception("Cannot find any csproj files.");
                }
                if (o.OutPath is null)
                {
                    o.OutPath = Path.Combine(o.ProjectPath, "..", "generated");
                }

                var compilation = await CreateComplitation(o);

                var typesToGenerate = GetTypesToGenerate(compilation);

                Console.WriteLine($"Generating {typesToGenerate.Length} files.");

                var componentWrapperGenerator = new ComponentWrapperGenerator();

                foreach (var generatedType in typesToGenerate)
                {
                    var (groupName, name, source) = componentWrapperGenerator.GenerateComponentFile(compilation, generatedType);
                    var (_, _, attachmentSource) = componentWrapperGenerator.GenerateAttachmentFile(compilation, generatedType);

                    var fileName = $"{name}.generated.cs";
                    var fileNameAttachment = $"{name}.generated.attachment.cs";

                    var path = string.IsNullOrEmpty(groupName)
                        ? Path.Combine(o.OutPath, fileName)
                        : Path.Combine(o.OutPath, groupName, fileName);

                    var pathAttachment = string.IsNullOrEmpty(groupName)
                        ? Path.Combine(o.OutPath, fileNameAttachment)
                        : Path.Combine(o.OutPath, groupName, fileNameAttachment);

                    Directory.GetParent(path).Create();

                    File.WriteAllText(path, source);
                    if (attachmentSource != "")
                    {
                        File.WriteAllText(pathAttachment, attachmentSource);
                    }

                }
            });
    }

    private static GenerateComponentSettings[] GetTypesToGenerate(Compilation compilation)
    {
        Console.WriteLine("Finding types to generate.");

        var refrences = compilation.References;


        var elementType = compilation.GetTypeByMetadataName("Avalonia.Animation.Animatable");
        var attributes = compilation.Assembly.GetAttributes();
        var typesToGenerate = attributes
            .Where(attribute => attribute.AttributeClass?.ToDisplayString() == "Blazonia.ComponentGenerator.GenerateComponentAttribute")
            .Select(attribute =>
            {
                var typeSymbol = attribute.ConstructorArguments.FirstOrDefault().Value as INamedTypeSymbol;

                var propertiesAliases =
                    GetNamedArgumentValues(attribute, "Aliases")
                    .Select(v => v.Split(':'))
                    .ToDictionary(v => v[0], v => v[1]);

                // Type alias has type name as a key.
                propertiesAliases.Remove(typeSymbol.Name, out var typeAlias);

                var setting = new GenerateComponentSettings
                {
                    FileHeader = FileHeader,
                    TypeAlias = typeAlias,
                    TypeSymbol = typeSymbol,
                    Exclude = GetNamedArgumentValues(attribute, "Exclude").ToHashSet(),
                    Include = GetNamedArgumentValues(attribute, "Include").ToHashSet(),
                    ContentProperties = GetNamedArgumentValues(attribute, "ContentProperties").ToHashSet(),
                    PropertyChangedEvents = GetNamedArgumentValues(attribute, "PropertyChangedEvents"),
                    GenericProperties = GetNamedArgumentValues(attribute, "GenericProperties").Select(v => v.Split(':')).ToDictionary(v => v[0],
                        v => v.ElementAtOrDefault(1) is string genericArgName ? compilation.GetTypeByMetadataName(genericArgName) : null),
                    Aliases = propertiesAliases,
                    IsGeneric = (attribute.NamedArguments.FirstOrDefault(a => a.Key == "IsGeneric").Value.Value as bool?) ?? false
                };
                return setting;
            })
            .Where(type => type.TypeSymbol != null)
            .ToList();

        var typesByAssembly = attributes
            .Where(attribute => attribute.AttributeClass?.ToDisplayString() == "Blazonia.ComponentGenerator.GenerateComponentsFromAssemblyAttribute")
            .SelectMany(attribute =>
            {


                var assemblyName = attribute.ConstructorArguments.FirstOrDefault().Value as string;



                var typeNamePrefix = attribute.NamedArguments.FirstOrDefault(a => a.Key == "TypeNamePrefix").Value.Value as string;


                var metadataReference = compilation.References.Where(refrences =>
                {
                    var path = refrences.Display;

                    var name = Path.GetFileNameWithoutExtension(path);

                    return name == assemblyName;

                }).FirstOrDefault();


                var assembly = compilation.GetAssemblyOrModuleSymbol(metadataReference) as IAssemblySymbol;
                var typesInAssembly = assembly
                    .GlobalNamespace.GetAllTypes()
                    .Where(type => type.DeclaredAccessibility == Accessibility.Public)
                    .Where(type => !(type.IsGenericType && type.IsDefinition))
                    .Where(type => SymbolEqualityComparer.Default.Equals(type , elementType) || compilation.ClassifyCommonConversion(type, elementType) is { IsReference: true, IsImplicit: true });

                var result = typesInAssembly
                    .Where(type => !typesToGenerate.Any(t => SymbolEqualityComparer.Default.Equals(t.TypeSymbol, type)))
                    .Select(type => {
                        return new GenerateComponentSettings
                        {
                            FileHeader = FileHeader,
                            TypeSymbol = type,
                            TypeAlias = typeNamePrefix is null ? null : typeNamePrefix + type.Name
                        };
                    });
                return result;
            })
            .ToList();
        typesToGenerate.AddRange(typesByAssembly);

        foreach (var info in typesToGenerate)
        {
            var baseTypeInfo = typesToGenerate.FirstOrDefault(t => SymbolEqualityComparer.Default.Equals(t.TypeSymbol, info.TypeSymbol?.BaseType));
            info.BaseTypeInfo = baseTypeInfo;
        }

        return typesToGenerate.ToArray();
    }

    private static string[] GetNamedArgumentValues(AttributeData attribute, string name)
    {
        var argumentConstant = attribute.NamedArguments.FirstOrDefault(a => a.Key == name).Value;

        if (argumentConstant.Kind != TypedConstantKind.Array)
            return Array.Empty<string>();

        var values = argumentConstant.Values;

        if (values.IsDefaultOrEmpty)
            return Array.Empty<string>();

        return values.Select(a => a.Value as string).Where(v => v is not null).ToArray();
    }

    private static async Task<Compilation> CreateComplitation(Options o)
    {
        Console.WriteLine("Creating project compilation.");

        var workspace = MSBuildWorkspace.Create();
        var project = await workspace.OpenProjectAsync(o.ProjectPath);
        var compilation = await project.GetCompilationAsync();

        return compilation;
    }

    private class Options
    {
        [Value(0, HelpText = "Project file path to run generator.")]
        public string ProjectPath { get; set; }

        [Option('o', "out-path", HelpText = "Out path for generated files.")]
        public string OutPath { get; set; }
    }
}
