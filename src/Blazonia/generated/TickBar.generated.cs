// <auto-generated>
//     This code was generated by a BlazorBindingsAvalonia component generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>



#pragma warning disable CA2252

namespace Blazonia.Components
{
    /// <summary>
    /// An element that is used for drawing <see cref="T:Avalonia.Controls.Slider" />'s Ticks.
    /// </summary>
    public partial class TickBar : Control
    {
        static TickBar()
        {
            RegisterAdditionalHandlers();
        }

        /// <summary>
        /// Brush used to fill the TickBar's Ticks.
        /// </summary>
        [Parameter] public OneOf.OneOf<global::Avalonia.Media.IBrush, global::Avalonia.Media.Color, string> Fill { get; set; }
        /// <summary>
        /// The IsDirectionReversed property defines the direction of value incrementation. By default, if Tick's orientation is Horizontal, ticks will be drawn from left to right. (And, bottom to top for Vertical orientation). If IsDirectionReversed is 'true' the direction of the drawing will be in opposite direction.
        /// </summary>
        [Parameter] public bool? IsDirectionReversed { get; set; }
        /// <summary>
        /// Logical position where the Maximum Tick will be drawn
        /// </summary>
        [Parameter] public double? Maximum { get; set; }
        /// <summary>
        /// Logical position where the Minimum Tick will be drawn
        /// </summary>
        [Parameter] public double? Minimum { get; set; }
        /// <summary>
        /// TickBar parent's orientation.
        /// </summary>
        [Parameter] public global::Avalonia.Layout.Orientation? Orientation { get; set; }
        /// <summary>
        /// Placement property specified how the Tick will be placed. This property affects the way ticks are drawn. This property has type of <see cref="T:Avalonia.Controls.TickBarPlacement" />.
        /// </summary>
        [Parameter] public AC.TickBarPlacement? Placement { get; set; }
        /// <summary>
        /// TickBar will use ReservedSpaceProperty for left and right spacing (for horizontal orientation) or top and bottom spacing (for vertical orientation). The space on both sides of TickBar is half of specified ReservedSpace. This property has type of <see cref="T:Avalonia.Rect" />.
        /// </summary>
        [Parameter] public OneOf.OneOf<global::Avalonia.Rect?, string> ReservedSpace { get; set; }
        /// <summary>
        /// TickFrequency property defines how the tick will be drawn.
        /// </summary>
        [Parameter] public double? TickFrequency { get; set; }
        /// <summary>
        /// The Ticks property contains collection of value of type Double which are the logical positions use to draw the ticks. The property value is a <see cref="T:Avalonia.Collections.AvaloniaList`1" />.
        /// </summary>
        [Parameter] public global::Avalonia.Collections.AvaloniaList<double> Ticks { get; set; }

        public new AC.TickBar NativeControl => (AC.TickBar)((AvaloniaObject)this).NativeControl;

        protected override AvaloniaBindableObject CreateNativeElement() => new AC.TickBar();

        protected override void HandleParameter(string name, object value)
        {
            switch (name)
            {
                case nameof(Fill):
                    if (!Equals(Fill, value))
                    {
                        Fill = (OneOf.OneOf<global::Avalonia.Media.IBrush, Avalonia.Media.Color, string>)value;
                        if (Fill.IsT0)
                        {
                            NativeControl.Fill = (global::Avalonia.Media.IBrush)Fill.AsT0;
                        }
                        else if (Fill.IsT1)
                        {
                            NativeControl.Fill = new global::Avalonia.Media.Immutable.ImmutableSolidColorBrush(Fill.AsT1);
                        }
                        else 
                        {
                            NativeControl.Fill = Avalonia.Media.Brush.Parse(Fill.AsT2);
                        }
                    }
                    break;
                case nameof(IsDirectionReversed):
                    if (!Equals(IsDirectionReversed, value))
                    {
                        IsDirectionReversed = (bool?)value;
                        NativeControl.IsDirectionReversed = IsDirectionReversed ?? (bool)AC.TickBar.IsDirectionReversedProperty.GetDefaultValue(AC.TickBar.IsDirectionReversedProperty.OwnerType);
                    }
                    break;
                case nameof(Maximum):
                    if (!Equals(Maximum, value))
                    {
                        Maximum = (double?)value;
                        NativeControl.Maximum = Maximum ?? (double)AC.TickBar.MaximumProperty.GetDefaultValue(AC.TickBar.MaximumProperty.OwnerType);
                    }
                    break;
                case nameof(Minimum):
                    if (!Equals(Minimum, value))
                    {
                        Minimum = (double?)value;
                        NativeControl.Minimum = Minimum ?? (double)AC.TickBar.MinimumProperty.GetDefaultValue(AC.TickBar.MinimumProperty.OwnerType);
                    }
                    break;
                case nameof(Orientation):
                    if (!Equals(Orientation, value))
                    {
                        Orientation = (global::Avalonia.Layout.Orientation?)value;
                        NativeControl.Orientation = Orientation ?? (global::Avalonia.Layout.Orientation)AC.TickBar.OrientationProperty.GetDefaultValue(AC.TickBar.OrientationProperty.OwnerType);
                    }
                    break;
                case nameof(Placement):
                    if (!Equals(Placement, value))
                    {
                        Placement = (AC.TickBarPlacement?)value;
                        NativeControl.Placement = Placement ?? (AC.TickBarPlacement)AC.TickBar.PlacementProperty.GetDefaultValue(AC.TickBar.PlacementProperty.OwnerType);
                    }
                    break;
                case nameof(ReservedSpace):
                    if (!Equals(ReservedSpace, value))
                    {
                        ReservedSpace = (OneOf.OneOf<global::Avalonia.Rect?,string>)value;
                        if (ReservedSpace.IsT0)
                        {
                            NativeControl.ReservedSpace = (global::Avalonia.Rect)ReservedSpace.AsT0;
                        }
                        else 
                        {
                            NativeControl.ReservedSpace = global::Avalonia.Rect.Parse(ReservedSpace.AsT1);
                        }
                    }
                    break;
                case nameof(TickFrequency):
                    if (!Equals(TickFrequency, value))
                    {
                        TickFrequency = (double?)value;
                        NativeControl.TickFrequency = TickFrequency ?? (double)AC.TickBar.TickFrequencyProperty.GetDefaultValue(AC.TickBar.TickFrequencyProperty.OwnerType);
                    }
                    break;
                case nameof(Ticks):
                    if (!Equals(Ticks, value))
                    {
                        Ticks = (global::Avalonia.Collections.AvaloniaList<double>)value;
                        NativeControl.Ticks = Ticks;
                    }
                    break;

                default:
                    base.HandleParameter(name, value);
                    break;
            }
        }

        static partial void RegisterAdditionalHandlers();
    }
}
